<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>UI réactive dans Unity</title>

    <link rel="stylesheet" href="dist/reset.css">
    <link rel="stylesheet" href="dist/reveal.css">
    <link rel="stylesheet" href="dist/theme/white.css">
    <link rel="stylesheet" href="dist/theme/fonts/plus-jakarta-sans/jakarta.css">
    <link rel="stylesheet" href="dist/theme/fonts/PPMonumentExtended-Bold/PPMonumentExtended-Bold.css">

    <!-- Theme used for syntax highlighted code -->
    <link rel="stylesheet" href="plugin/highlight/zenburn.css">

    <style>
        * {
            --r-main-font: Jakarta, sans-serif;
        }

        * h1 {
            --r-heading-font: PPMonumentExtended, sans-serif;
            --r-heading1-size: 1.6em;
        }

        * h2, * h3, * h4 {
            --r-heading-font: Jakarta, sans-serif;
            --r-heading2-size: 4.5rem;
            --r-heading3-size: 2.5rem;
        }

        section > section.past:first-child {
            display: block !important;
            opacity: 1 !important;
            transform: translate(0, 0) !important;
            top: 0px !important;
        }

        section > section.past:first-child * {
            font-size: 36px !important;
            margin-top: 10px;
        }

        .reveal section img {
            border: none;
            outline: 4px solid black;
        }

        .reveal section img.no-border {
            border: none;
            outline: 0;
        }

        .reveal pre code {
            max-height: 460px;
        }

        .reveal pre {
            width: 100%;
        }

        small, .small {
            font-size: 36px !important;
        }

        .smaller {
            font-size: 30px !important;
        }

        pre.small {
            font-size: 24px !important;
        }

        pre.smaller {
            font-size: 20px !important;
        }
    </style>
</head>
<body>
<div class="reveal">
    <div class="slides">
        <section>
            <h1>UI réactive dans Unity</h1>
            <em>Pourquoi et comment brancher sa UI sur un state observable ?</em>
        </section>
        <section><h2>Samuel BOUCHET</h2>
            <div>Développeur Unity chez Lonestone</div>

            <img src="assets/photo.png" style="width: 200px;height: auto;"/>

            <div><a href="https://twitter.com/Lythom">@Lythom</a></div>

            <aside class="notes">
                <li>formation Ingénieur logiciel</li>
                <li>Société de service / édition logicielle / Web / JavaScript / 5 ans de Jeux Vidéo (34 ans)</li>
                <li>Développeur JS</li>
            </aside>
        </section>
        <!-- Le plan -->
        <section>
            <section>
                <h2>Le plan</h2>
                <ol>
                    <li>Histoire</li>
                    <li>Intérêt et limite</li>
                    <li>Structure pour StarTeam</li>
                    <li>Code review et démo</li>
                </ol>
                <div><img src="assets/giphy_lookup.webp" alt="" height="160"></div>
                <aside class="notes">
                    <li>Comment est née l'idée ? De quoi est-ce qu'il s'agit ?</li>
                    <li>=> Gestionnaire de l'état de l'application et branchement de la UI</li>
                    <li>Pourquoi ou pourquoi pas ?</li>
                    <li>Structure: Comment ?</li>
                    <li>Code review: implémentation sur mesure pour StarTeam</li>
                </aside>
            </section>
        </section>
        <!-- La réactivité -->
        <section>
            <section>
                <h2>L'histoire (1/4)</h2>
            </section>
            <section>
                <h3>Le web en 2013</h3>
                <ul>
                    <li class="small">Les webmestres préfixent leur recherche par <code>JQuery</code></li>
                    <li class="small">La boucle classique est <img src="assets/flow_http_server.png"
                                                                   alt="Requête Http → Contrôleur → Donnée → Vue → Requête Http"/>
                    </li>
                </ul>
            </section>
            <section>
                <h3>Apparition de React</h3>
                <ul>
                    <li class="small">React est une bibliothèque de rendu</li>
                    <li class="small">La promesse: <code>Vue=fn(Donnée)</code>
                        <ul>
                            <li>
                                → Paradigme déclaratif
                            </li>
                        </ul>
                    </li>
                    <li class="small">Collocalisation de la vue et du comportement: Programmation par composant</li>
                </ul>
            </section>
            <section>
                <h3>Flux & Redux (2015)</h3>
                <div>one-way data flow structure</div>
                <figure>
                    <img src="assets/flow_flux.png" alt="Action → Dispatcher → Store → View → Action"/>
                    <figcaption style="font-size: 16px;margin:0;padding:0;height:0">Source:
                        https://facebook.github.io/flux/docs/in-depth-overview/
                    </figcaption>
                </figure>
                <aside class="notes">
                    <li>Structure similaire au web client/server mais local</li>
                    <li>Store centralisé: une seule source de vérité monolithique, minimale mais suffisante (aucune
                        donnée calculée)
                    </li>
                    <li>Les vues s'abonnent aux données et se mettent à jour en réaction aux changement de données</li>
                    <li>La forme de la donnée est figée (~base de donnée)</li>
                </aside>
            </section>
            <section>
                <h3>On s'inspire et on garde:</h3>
                <ol>
                    <li>Circulation des données en sens unique</li>
                    <li>Organisation en composants autonomes</li>
                    <li>Le composant s'abonne aux fragments de données dont il a besoin</li>
                    <li>Centralisation du store minimal mais suffisant</li>
                    <li>Utilisation de sélecteurs pour accéder aux données calculées</li>
                </ol>
                <aside class="notes">
                    <li>1. Une action ne modifie pas la vue, ni la donnée directement</li>
                    <li>2. On regroupe vue et comportements. !Cette notion de composant est différente de celle de
                        Unity. Ici composant ~= prefab.
                    </li>
                </aside>
            </section>
            <section>
                <h3>Démo</h3>
                <!--              <div>TODO une implémentation Unity minimaliste pour illustrer</div>-->
                <!--              <div>TODO une implémentation Unity minimaliste pour illustrer</div>-->
                <!--              <div>TODO une implémentation Unity minimaliste pour illustrer</div>-->
                <!--              <div>TODO une implémentation Unity minimaliste pour illustrer</div>-->
                <!--              <div>TODO une implémentation Unity minimaliste pour illustrer</div>-->
                <!--              <div>TODO une implémentation Unity minimaliste pour illustrer</div>-->
                <!--              <div>TODO une implémentation Unity minimaliste pour illustrer</div>-->
                <!--              <div>TODO une implémentation Unity minimaliste pour illustrer</div>-->
                <!--              <div>TODO une implémentation Unity minimaliste pour illustrer</div>-->
                <!--              <div>TODO une implémentation Unity minimaliste pour illustrer</div>-->
                <!--              <div>TODO une implémentation Unity minimaliste pour illustrer</div>-->
                <!--              <div>TODO une implémentation Unity minimaliste pour illustrer</div>-->
                <!--              <div>TODO une implémentation Unity minimaliste pour illustrer</div>-->
                <!--              <div>TODO une implémentation Unity minimaliste pour illustrer</div>-->
                <!--              <div>TODO une implémentation Unity minimaliste pour illustrer</div>-->
                <!--              <div>TODO une implémentation Unity minimaliste pour illustrer</div>-->
                <!--              <div>TODO une implémentation Unity minimaliste pour illustrer</div>-->
                <!--              <div>TODO une implémentation Unity minimaliste pour illustrer</div>-->
                <!--              <div>TODO une implémentation Unity minimaliste pour illustrer</div>-->
                <!--              <div>TODO une implémentation Unity minimaliste pour illustrer</div>-->
                <!--              <div>TODO une implémentation Unity minimaliste pour illustrer</div>-->
                <!--              <div>TODO une implémentation Unity minimaliste pour illustrer</div>-->
                <!--              <div>TODO une implémentation Unity minimaliste pour illustrer</div>-->
                <!--              <div>TODO une implémentation Unity minimaliste pour illustrer</div>-->
                <!--              <div>TODO une implémentation Unity minimaliste pour illustrer</div>-->
                <!--              <div>TODO une implémentation Unity minimaliste pour illustrer</div>-->
                <!--              <div>TODO une implémentation Unity minimaliste pour illustrer</div>-->
                <!--              <div>TODO une implémentation Unity minimaliste pour illustrer</div>-->
            </section>
        </section>
        <section>
            <section>
                <h2 style="white-space: nowrap">Intérêts et limites (2/4)</h2>
            </section>
            <section>
                <h3>Raison 1 : Prédictibilité</h3>
                <blockquote class="smaller">Les modèles et les outils fournis par Redux permettent de comprendre plus
                    facilement <b>quand, où, pourquoi et comment l'état de votre application est mis à jour</b>, et <b>comment
                        la logique de votre application se comportera</b> lorsque ces changements se produiront.
                </blockquote>
                <div style="white-space: nowrap; font-size: 20px">Source:
                    https://redux.js.org/tutorials/essentials/part-1-overview-concepts
                </div>
            </section>

            <section>
                <h3>Raison 2 : Transactionnalité</h3>
                <ul class="small">
                    <li>En modifiant le state action après action, on garantit son intégrité.</li>
                    <li>Mise en réseau: les changements de states sont spécifiés et normalisés, ce qui facilite la
                        transmission de messages de changement d'état
                    </li>
                </ul>
            </section>

            <section>
                <h3>Raison 3 : Injection d'état</h3>
                <ul>
                    <li>Phase de dev:
                        <ul class="small">
                            <li>mettre le jeu dans l'état où la fonctionnalité est testable</li>
                        </ul>
                    </li>
                    <li>Phase de debug:
                        <ul class="small">
                            <li>attacher une image de l'état du jeu lors d'une remontée de bug</li>
                            <li>mettre le jeu dans l'état où le bug est reproductible</li>
                        </ul>
                    </li>
                    <li>Phase de runtime:
                        <ul class="small">
                            <li>initialiser une sauvegarde de n'importe quel état</li>
                        </ul>
                    </li>
                </ul>
                <aside class="notes">
                    <li>Pourquoi vouloir ce système pour nos jeux ?</li>
                    <li>Si un joueur remonte un bug à la 25eme étape qui n'est affichée que les soirs de pleine lune,
                        dévélopper la feature et reproduire peut être fastidieux
                    </li>
                    <li></li>
                </aside>
            </section>

            <section>
                <h3>Raison 4 : Testabilité</h3>
                <div>Démo un peu plus loin</div>
            </section>

            <section>
                <h3>Raison 5 : Voyage dans le temps</h3>
                <div>Fonctionnalité de undo: garder une sauvegarde de l'état précédent.</div>
            </section>

            <section>
                <h3>Raison 6 : Découpler données et vue</h3>
                <ul class="small">
                    <li>Souvent dans Unity, les objets de la scène sont source de vérité mais cette donnée n'est pas
                        accessible facilement au serveur et aux autres joueurs
                    </li>
                </ul>
                <div class="small">→ En déportant la source de vérité dans un state dédié, et en construisant les
                    composants comme des "images réactives" de cet état on facilite le partage et les tests.
                </div>
            </section>

            <section>
                <h3>Limite 1 : Lourdeur et rigueur</h3>
                <ul>
                    <li class="small">Les changements de states doivent être spécifiés et normalisés
                        <ul class="smaller">
                            <li>Du boilerplate</li>
                        </ul>
                    </li>
                    <li class="small">Le state devra suivre une structure précise et cohérente
                        <ul class="smaller">
                            <li>Soit en contrôlant avec le l'outillage</li>
                            <li>Soit en faisant preuve de rigueur (code reviews et bonne compréhension des mécaniques
                                par tous les membres de l'équipe)
                            </li>
                        </ul>
                    </li>
                </ul>
            </section>
            <section>
                <h3>Limite 2 : Nécessite une compréhension globale du système</h3>
                <ul class="small">
                    <li>Une action = une transaction. Ex: Une action pour changer les point de vie ? NON
                        <ul class="smaller">
                            <li>→ Une action "utilisation d'un objet"</li>
                            <li>→ Une action "échec d'un jet de risque"</li>
                            <li>→ Etc.</li>
                        </ul>
                    </li>
                    <li>Source de vérité unique centralisée (Single source of truth)
                        <ul class="smaller">
                            <li>Non redondance</li>
                            <li>Externalisation des données calculées</li>
                        </ul>
                    </li>
                    <li>State en lecture seule</li>
                </ul>
                <aside class="notes">
                    Habitudes de programmations peu habituelles pour les devs et il s'y conformer n'est pas évident
                </aside>
            </section>
            <section>
                <h3>Limite 3 : Animations et transitions</h3>
                <ul class="small">
                    <li>Les états n'indiquent que la situation finale</li>
                    <li>Chaque composant est autonome pour passer de son état actuel vers son état cible, ce qui rend
                        l'orchestration difficile.
                    </li>
                </ul>
            </section>
            <!-- Problématique 1 -->
            <!--<section>
                <h3 style="margin:0">Problématique 1</h3>
                <div class="small">Notification de changement</div>
                <pre class="smaller fragment fade-in-then-out" style="position: absolute" data-id="code-animation"><code
                        class="language-cs" data-trim data-line-numbers>
                    public class ThemeChanger : MonoBehaviour {
                        public Button ChangeThemeButton;
                        public Image Header;
                        public Image Footer;

                        public void Awake() {
                            ChangeThemeButton.AddListener(() => {
                                Header.color = Color.black;
                                Footer.color = Color.black;
                                // Et comment je met à jour les autres composants à thème ?
                            });
                        }
                    }
                </code></pre>
                <pre class="smaller fragment fade-in-then-out" style="position: absolute" data-id="code-animation"><code
                        class="language-cs" data-trim data-line-numbers>
                    public class ThemeChanger : MonoBehaviour {
                        public Button ChangeThemeButton;
                        public Image Header;
                        public Image Footer;
                        // une liste de toutes les références
                        public SomeComponent SomeComponent;
                        public SomeOtherComponent SomeOtherComponent;
                        // à maintenir à jour
                        // des références couplées à travers tout le projet
                        // comment gérer instantiations dynamiques ?

                        public void Awake() {
                            ChangeThemeButton.AddListener(() => {
                                Header.color = Color.black;
                                Footer.color = Color.black;
                                SomedComponent.SomeImage.color = Color.black;
                                SomeOtherdComponent.SomeImage.color = Color.black;
                            });
                        }
                    }
                </code></pre>
                <pre class="smaller fragment fade-in-then-out" style="position: absolute" data-id="code-animation"><code
                        class="language-cs" data-trim data-line-numbers>
                    public class ThemeChanger : MonoBehaviour {
                        public Button ChangeThemeButton;
                        public Image Header;
                        public Image Footer;

                        public void Awake() {
                            ChangeThemeButton.AddListener(() => {
                                Header.color = Color.black;
                                Footer.color = Color.black;
                                SomeBroker.Publish(new ThemeChangeEvent(Color.black))
                                // Lorsque j'instancie un nouveau composant,
                                // comment connaitre le thème en cours ?
                            });
                        }
                    }
                </code></pre>
                <aside class="notes">
                    <li>PubSub ok pour le flux "push" mais pas pour le "pull"</li>
                </aside>
            </section>-->
            <!-- Problématique 1 - Solution ? -->
            <!--<section>
                <h3>Problématique 1 - La solution idéale</h3>
                <ul>
                    <li>Expose les changements à qui veut s'abonner (PubSub)</li>
                    <li>Mémorise la dernière valeur connue</li>
                </ul>
            </section>-->
            <!-- Problématique 2 -->
            <!-- <section>
                 <h3 style="margin:0">Problématique 2</h3>
                 <div class="small">Source de vérité</div>
                 <pre class="smaller fragment fade-in-then-out" style="position: absolute" data-id="code-animation"><code
                         class="language-cs" data-trim data-line-numbers>
                     public class Level : MonoBehaviour {
                         public float FloorY = 5f;
                     }
                     public class PlayerManager : MonoBehaviour {
                         public Level CurrentLevel;
                         public Player P1;
                         public void Awake() => P1.SetStartingY(CurrentLevel.FloorY);
                     }
                     public class PlayerA : MonoBehaviour {
                         public float StartingY;
                         public void SetStartingY(float floorY) => StartingY = floorY;
                         public void PlayFXOnFloor() => SuperFX.PlayAtY(StartingY);
                         // Dans le dernier patch on fait bouger le sol: StartingY n'est plus à jour
                         // Oh no !
                     }
                 </code></pre>
                 <pre class="smaller fragment fade-in-then-out" style="position: absolute" data-id="code-animation"><code
                         class="language-cs" data-trim data-line-numbers>
                     public class Level : MonoBehaviour {
                         public float FloorY = 5f;
                     }
                     public class PlayerManager : MonoBehaviour {
                         public Level CurrentLevel;
                         public Player P1;
                         public void Awake() => P1.SetStartingY(CurrentLevel.FloorY);
                     }
                     public class PlayerA : MonoBehaviour {
                         public void PlayFXOnFloor(float floorY) => SuperFX.PlayAtY(floorY);
                         // solution statless: qq1 d'autre gère l'état à ma place
                     }
                 </code></pre>
                 <pre class="smaller fragment fade-in-then-out" style="position: absolute" data-id="code-animation"><code
                         class="language-cs" data-trim data-line-numbers>
                     public class Level : MonoBehaviour {
                         public float FloorY = 5f;
                     }
                     public class PlayerManager : MonoBehaviour {
                         public Level CurrentLevel;
                         public Player P1;
                         public void Awake() => P1.SetLevel(CurrentLevel);
                     }
                     public class PlayerA : MonoBehaviour {
                         public Level CurrentLevel;
                         public void SetStartingY(Level level) => CurrentLevel = level;
                         public void PlayFXOnFloor() => SuperFX.PlayAtY(CurrentLevel.FloorY);
                         // Dans le dernier patch on a aussi besoin de l'age du capitaine
                         // Oh no !
                     }
                 </code></pre>
                 <aside class="notes">
                     <li>Oh no j'ai oublié de refacto le nom de la méthode</li>
                 </aside>
             </section>-->
            <!-- Problématique 2 - La solution idéale -->
            <!-- <section>
                 <h3>Problématique 2 - La solution idéale</h3>
                 <ul>
                     <li>Soit notre composant est purement stateless
                         <ul class="smaller">
                             <li>Et il est indépendant du state et complètement portable.</li>
                         </ul>
                     </li>
                     <li style="margin-top: 25px;">Soit il on lui donner accès à l'entièreté du state
                         <ul class="smaller">
                             <li>Et il est couplé à l'application mais entièrement autonome.</li>
                         </ul>
                     </li>
                 </ul>
             </section>-->
            <!-- Paradigme impératif / déclaratif -->
            <!-- <section>
                 <ul>
                     <li class="fragment semi-fade-out" data-fragment-index="2">Paradigme impératif / événementiel :
                         <ul class="small">
                             <li>événement → rendu</li>
                         </ul>
                     </li>
                     <li class="fragment" data-fragment-index="1" style="margin-top: 25px">Paradigme déclaratif :
                         <ul class="small">
                             <li>donnée source → rendu</li>
                             <li>événément → donnée source</li>
                         </ul>
                     </li>
                 </ul>
                 <aside class="notes">
                     <li>Paradigme impératif / événementiel : un événement (clic, touche clavier) modifie le rendu
                         directement dans une fonction de rappel. Classiquement à grande échelle:
                         <ul>
                             <li>bus d'événements,
                             <li>Publish-subscribe
                                 pattern,
                             <li>implémentation directe des fonctions de rappels (ex: clic => tween fade out puis
                                 setActive(false)),
                             <li>Managers,
                             <li>Singletons ou appels statics.
                             <li>→ Couplage entre le code qui reçoit l'événement et le code qui modifie le rendu.</li>
                         </ul>
                     </li>
                     <li>En paradidme déclaratif: chaque vue calcule son rendu en fonction des données sources. Les
                         événements ne modifient pas le rendu mais les données sources, et le rendu est calculé en
                         cascade.
                         <br/>→ Couplage entre le code qui modifie le rendu et la donnée
                     </li>
                 </aside>
             </section>-->
            <!-- Composant = vue -->
            <!-- <section>
                 <h3>Découpage en composants</h3>
                 <ul>
                     <li>Unity = approche orientée composants
                         <ul class="small">
                             <li>composant <br/>= un comportement associé à un game object <br/>= MonoBehaviour</li>
                         </ul>
                     </li>
                     <li>Approche "web"
                         <ul class="small">
                             <li>composant = une vue</li>
                         </ul>
                     </li>
                 </ul>
                 <aside class="notes">
                     <li>Unity - Component = Behaviour</li>
                     <li>Moi : Component = Vue</li>
                 </aside>
             </section>-->
        </section>

        <section>
            <section>
                <h2 style="white-space: nowrap">Architecture Générale (3/4)</h2>
            </section>
            <section>
                État de l'application (state) découpé en 4 :
                <ol>
                    <li>Données statiques</li>
                    <li>Règles de jeu</li>
                    <li>Données de partie (GameState)</li>
                    <li>Données locales (LocalState)</li>
                </ol>
            </section>
            <section>
                <h3>Données statiques</h3>
                <ul>
                    <li>Context: client + serveur</li>
                    <li>Cycle de modification : version</li>
                    <li>Initialisées au démarrage de l'application</li>
                    <li>Immuables, accès en lecture seul global et static</li>
                </ul>
            </section>
            <section>
                <h3>Règles du jeu</h3>
                <ul>
                    <li>Context: client + serveur</li>
                    <li>Cycle de modification : une partie</li>
                    <li>Transmises avec la partie (1 fois)</li>
                    <li>Immuables, accès en lecture seule</li>
                </ul>
            </section>
            <section>
                <h3>Données de jeu</h3>
                <ul>
                    <li>Context: client + serveur</li>
                    <li>Cycle de modification : une action</li>
                    <li>Transmises 1 fois lors de la connexion</li>
                    <li>Mise à jour synchronisée serveur / clients</li>
                </ul>
            </section>
            <section>
                <h3>Données locales</h3>
                <ul>
                    <li>Context: client</li>
                    <li>Cycle de modification : à volonté</li>
                    <li>Une instance par client, jamais transmise</li>
                </ul>
            </section>
            <section>
                <h3>Outils de lecture du state</h3>
                - Les accesseurs pour faciliter l'utilisation et découpler l'utilisation du state de sa forme
                - Des sélecteurs pour mémoïser des données calculées
                - Un composant surchargeable (ConnectedMonoBehaviour) qui fournit les accès au state
            </section>
        </section>

        <section>
            <section>
                <h2>Code review (4/4)</h2>
            </section>
            <section>
                <h3>Tests</h3>
            </section>
        </section>

        <section>
            <section>
                <h2>Conclusion</h2>
            </section>
        </section>

        <!-- Le monsieur qui parle -->
        <section>
            <section><h2>Samuel BOUCHET</h2></section>
            <section>
                <div>Développeur Unity chez Lonestone</div>

                <img src="assets/photo.png" style="width: 200px;height: auto;"/>

                <div><a href="https://twitter.com/Lythom">@Lythom</a></div>

                <aside class="notes">
                    <li>formation Ingénieur logiciel</li>
                    <li>Société de service / édition logicielle / Web / JavaScript / 5 ans de Jeux Vidéo (34 ans)</li>
                    <li>Développeur JS</li>
                </aside>
            </section>
            <section style="background: black;color: white;">
                <h3 style="color: white;"><a href="https://a-time-paradox.com/"><img src="assets/lythom_atimeparado.jpg"
                                                                                     alt="A Time Paradox" height="600"/></a>
                </h3>
                <aside class="notes">
                    <li>A Time Paradox</li>
                    <li>Solo + freelances - Sorti en 2019 Android + PC</li>
                    <li>Développé avec Unity</li>
                </aside>
            </section>
            <section>
                <h3>Mod minecraft - Capsule</h3>
                <img src="assets/lythom_capsule.gif" style="margin: 0"/>
                <div><img src="assets/capsule_dls.png" class="no-border" style="margin: 0"/></div>
                <a href="https://minecraft.curseforge.com/projects/capsule">https://minecraft.curseforge.com/projects/capsule</a>
            </section>
            <section>
                <h3>City Invaders</h3>
                <span>
                <img src="assets/CI_Screenshot_02.jpg" style="margin: 0" width="460"/>
                <img src="assets/CI_Screenshot_05.jpg" style="margin: 0" width="460"/>
                <img src="assets/CI_Screenshot_06.jpg" style="margin: 0" width="460"/>
                <img src="assets/logo-lonestone-studio.png" style="margin: 40px 0 0 0;vertical-align: top; outline: 0"
                     width="460"/>
                </span>
                <aside class="notes">
                    <li>Chez Lonestone depuis 2 ans</li>
                </aside>
            </section>
        </section>
    </div>
</div>

<script src="dist/reveal.js"></script>
<script src="plugin/notes/notes.js"></script>
<script src="plugin/markdown/markdown.js"></script>
<script src="plugin/highlight/highlight.js"></script>
<script>
    // More info about initialization & config:
    // - https://revealjs.com/initialization/
    // - https://revealjs.com/config/
    Reveal.initialize({
        hash: true,

        // Learn about plugins: https://revealjs.com/plugins/
        plugins: [RevealMarkdown, RevealHighlight, RevealNotes]
    });
</script>
</body>
</html>
